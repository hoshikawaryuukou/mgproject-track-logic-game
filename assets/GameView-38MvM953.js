var g=Object.defineProperty;var B=(n,e,t)=>e in n?g(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var a=(n,e,t)=>B(n,typeof e!="symbol"?e+"":e,t);import{f as P,r as c,d as W,g as v,o as _,a as G,c as E,e as u,t as k,b as M}from"./index-d5yooDNu.js";import{B as z}from"./Board-BYsz5W2X.js";var p=(n=>(n.Clockwise="Clockwise",n.CounterClockwise="CounterClockwise",n))(p||{});class R{constructor(){a(this,"boardSize",16);a(this,"clockwiseMap",[1,2,3,7,0,6,10,11,4,5,9,15,8,12,13,14]);a(this,"counterClockwiseMap",[4,0,1,2,8,9,5,3,12,10,6,7,13,14,15,11]);a(this,"winLines",[[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[0,4,8,12],[1,5,9,13],[2,6,10,14],[3,7,11,15],[0,5,10,15],[3,6,9,12]]);a(this,"stones",Array(this.boardSize).fill(null))}placeStone(e,t){if(this.stones[e]!==null)throw new Error("Cell is already occupied");if(e<0||e>=this.stones.length)throw new Error("Invalid cell index");this.stones[e]=t}moveStones(e){const t=e==="Clockwise"?this.clockwiseMap:this.counterClockwiseMap,s=[];for(let o=0;o<this.stones.length;o++)s[t[o]]=this.stones[o];this.stones=s}checkWin(e){for(const t of this.winLines)if(t.every(s=>this.stones[s]===e))return!0;return!1}isEmpty(e){return this.stones[e]===null}isFull(){return this.stones.every(e=>e!==null)}getStones(){return[...this.stones]}}var l=(n=>(n.Black="X",n.White="O",n))(l||{});class S{constructor(){a(this,"board");a(this,"currentPlayer");a(this,"winner");this.board=new R,this.currentPlayer=l.Black,this.winner=null}placeStone(e){if(this.winner!==null||!this.board.isEmpty(e))return;this.board.placeStone(e,this.currentPlayer),this.board.moveStones(p.Clockwise);const t=this.board.checkWin(l.Black),s=this.board.checkWin(l.White);t&&s?this.winner="Draw":t?this.winner=l.Black:s?this.winner=l.White:this.board.isFull()?this.winner="Draw":this.currentPlayer=this.currentPlayer===l.Black?l.White:l.Black}getState(){return{stones:this.board.getStones(),currentPlayer:this.currentPlayer,winner:this.winner}}}const V=P("game",()=>{const n=c(new S),e=c(l.Black),t=c(null);return{currentPlayer:e,winner:t,initializeGame:()=>{n.value=new S,e.value=l.Black,t.value=null},placeStone:h=>{n.value.placeStone(h);const i=n.value.getState();console.log(i),e.value=i.currentPlayer,t.value=i.winner}}}),X={class:"about"},N=W({__name:"GameView",setup(n){const e=V(),t=c(),s=c(!0),o=v(()=>b(e.currentPlayer)),h=v(()=>e.winner===null?null:C(e.winner)),i=()=>{var r;e.initializeGame(),(r=t.value)==null||r.resetStones(),s.value=!0},y=async r=>{var w,f,m;if(s.value!==!1){if(((w=t.value)==null?void 0:w.isCellEmpty(r))===!1){console.log("該位置已被佔用，請選擇其他位置。");return}e.placeStone(r),(f=t.value)==null||f.addStone(r),s.value=!1,await new Promise(d=>setTimeout(d,200)),(m=t.value)==null||m.moveStones("clockwise"),await new Promise(d=>setTimeout(d,200)),e.winner!==null?s.value=!1:s.value=!0}},b=r=>r==="X"?"⚫":"⚪",C=r=>{switch(r){case"X":return"⚫";case"O":return"⚪";default:return"😐"}};return _(()=>{i()}),(r,w)=>(G(),E("div",X,[u("div",null,"當前玩家: "+k(o.value),1),u("div",null,"遊戲結果: "+k(h.value),1),M(z,{ref_key:"boardRef",ref:t,onCellClicked:y},null,512),u("div",{class:"buttons"},[u("button",{class:"reset-button",onClick:i},"重置遊戲")])]))}});export{N as default};
