var g=Object.defineProperty;var B=(s,e,t)=>e in s?g(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var o=(s,e,t)=>B(s,typeof e!="symbol"?e+"":e,t);import{f as P,r as i,d as W,o as G,a as d,c as v,e as f,t as S,b as E}from"./index-F8ABe11o.js";import{B as M}from"./Board-EFit_Evz.js";var b=(s=>(s.Clockwise="Clockwise",s.CounterClockwise="CounterClockwise",s))(b||{});class z{constructor(){o(this,"boardSize",16);o(this,"clockwiseMap",[1,2,3,7,0,6,10,11,4,5,9,15,8,12,13,14]);o(this,"counterClockwiseMap",[4,0,1,2,8,9,5,3,12,10,6,7,13,14,15,11]);o(this,"winLines",[[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[0,4,8,12],[1,5,9,13],[2,6,10,14],[3,7,11,15],[0,5,10,15],[3,6,9,12]]);o(this,"stones",Array(this.boardSize).fill(null))}placeStone(e,t){if(this.stones[e]!==null)throw new Error("Cell is already occupied");if(e<0||e>=this.stones.length)throw new Error("Invalid cell index");this.stones[e]=t}moveStones(e){const t=e==="Clockwise"?this.clockwiseMap:this.counterClockwiseMap,n=[];for(let a=0;a<this.stones.length;a++)n[t[a]]=this.stones[a];this.stones=n}checkWin(e){for(const t of this.winLines)if(t.every(n=>this.stones[n]===e))return!0;return!1}isEmpty(e){return this.stones[e]===null}isFull(){return this.stones.every(e=>e!==null)}getStones(){return[...this.stones]}}var l=(s=>(s.Black="X",s.White="O",s))(l||{});class p{constructor(){o(this,"board");o(this,"currentPlayer");o(this,"winner");this.board=new z,this.currentPlayer=l.Black,this.winner=null}placeStone(e){if(this.winner!==null||!this.board.isEmpty(e))return;this.board.placeStone(e,this.currentPlayer),this.board.moveStones(b.Clockwise);const t=this.board.checkWin(l.Black),n=this.board.checkWin(l.White);t&&n?this.winner="Draw":t?this.winner=l.Black:n?this.winner=l.White:this.board.isFull()?this.winner="Draw":this.currentPlayer=this.currentPlayer===l.Black?l.White:l.Black}getState(){return{stones:this.board.getStones(),currentPlayer:this.currentPlayer,winner:this.winner}}}const R=P("game",()=>{const s=i(new p),e=i(l.Black),t=i(null);return{currentPlayer:e,winner:t,initializeGame:()=>{s.value=new p,e.value=l.Black,t.value=null},placeStone:c=>{s.value.placeStone(c);const u=s.value.getState();console.log(u),e.value=u.currentPlayer,t.value=u.winner}}}),V={class:"about"},X={class:"status"},D={key:0,class:"current-player"},F={key:1,class:"game-result"},T=W({__name:"GameView",setup(s){const e=R(),t=i(),n=i(!0),a=i(null),c=i(null),u=()=>{var r;e.initializeGame(),(r=t.value)==null||r.resetStones(),n.value=!0,a.value=m(e.currentPlayer),c.value=null},C=async r=>{var h,k,y;if(n.value!==!1){if(((h=t.value)==null?void 0:h.isCellEmpty(r))===!1){console.log("該位置已被佔用，請選擇其他位置。");return}e.placeStone(r),(k=t.value)==null||k.addStone(r),n.value=!1,await new Promise(w=>setTimeout(w,200)),(y=t.value)==null||y.moveStones("clockwise"),await new Promise(w=>setTimeout(w,200)),a.value=m(e.currentPlayer),e.winner!==null?(c.value=_(e.winner),n.value=!1):n.value=!0}},m=r=>r==="X"?"⚫":"⚪",_=r=>{switch(r){case"X":return"⚫";case"O":return"⚪";default:return"😐"}};return G(()=>{u()}),(r,h)=>(d(),v("div",V,[f("div",X,[c.value===null?(d(),v("div",D," 當前玩家: "+S(a.value),1)):(d(),v("div",F,"遊戲結果: "+S(c.value),1))]),E(M,{ref_key:"boardRef",ref:t,onCellClicked:C},null,512),f("div",{class:"buttons"},[f("button",{class:"reset-button",onClick:u},"重置遊戲")])]))}});export{T as default};
